# 算术运算和数据对齐

1. 在我们`pandas`中有一个很重要的特性，不同的索引对象之间可以进行算术运算(加，减，乘，除...)

   ```python 
   #我们可以先看案例,不同的索引对象相加
   
   #Series
   s1 = pd.Series(np.random.rand(4),index=['a','b','c','d'])*100
   s2 = pd.Series(np.random.rand(4),index=['a','d','e','f'])*100
   
   s1
   a    72.868475
   b    86.868903
   c    74.800287
   d    59.727382
   dtype: float64
   
   s2
   a    90.683489
   d    34.670433
   e    12.572728
   f    82.626782
   dtype: float64
   #将s1和s2对象相加
   s1 + s2
   a    163.551964
   b           NaN
   c           NaN
   d     94.397815
   e           NaN
   f           NaN
   dtype: float64
   """
   我们不同的Series对象进行算术运算,在没有相同的标签位置上,内部数据对齐就会产生缺失值,具有相同的标签的值,会进行算术运算,索引对不相同,返回的结果的索引就是索引对的并集,Series进行算术运算的时候,不需要保证Series大小的一致
   """
   
   #DataFrame
   df1 = pd.DataFrame(np.random.rand(12).reshape(4,3)*100, index=['a','b','c','d'],columns=list('ABC'))
   
   df2 = pd.DataFrame(np.random.rand(9).reshape(3,3)*100, index=['a','d','f'],columns=list('ABD'))
   
   df1
   	A			B			C
   a	26.869112	70.599906	32.586599
   b	46.996796	19.524614	74.472748
   c	94.605620	94.174812	29.406223
   d	93.409041	56.094164	21.006926
   
   df2
   		A		B			D
   a	81.508766	61.112238	94.539634
   d	7.888379	90.192787	3.874301
   f	8.415423	52.471031	43.082653
   
   df1+df2
   	A			B			C	   D
   a	108.377878	131.712144	 NaN	NaN
   b	NaN			NaN			NaN	   NaN
   c	NaN			NaN			NaN	   NaN
   d	101.297420	146.286951	 NaN	NaN
   f	NaN			NaN			NaN	   NaN
   """
   将两个不同的DataFrame进行算术，返回一个DataFrame，它的行索引和列索引，是每个DataFrame的索引,列的并集,在没有相同的标签位置上,内部数据对齐就会产生缺失值,具有相同的标签的值,会进行算术运算,
   """
   ```

2. 使用填充值的`算术方法`:

   如上面的案例一样，两个不同的索引对象之间进行算术操作时，当一个标签存在一个对象上，在另外的一个对象中不存在，会出现缺失值，我们可以通过下表中的`算术方法`将缺失值进行填充。

   **算术方法表**:

   |        方法         |     描述     |
   | :-----------------: | :----------: |
   |      add，sadd      |  加法（+）   |
   |      sub，rsub      |  减法（-）   |
   |      div，rdiv      |  除法（/）   |
   | floordiv，rfllordiv |  整除（//）  |
   |      mul，rmul      |  乘法（*）   |
   |      pow，rpow      | 幂次方（**） |

   ```python
   #我们对上面的案例使用算术方法实现
   s1.add(s2) 
   a    163.551964
   b           NaN
   c           NaN
   d     94.397815
   e           NaN
   f           NaN
   dtype: float64
   #效果和我们的s1 + s2等同，算术方法中有个参数,fill_value参数，可以对缺失值进行填充
   s1.add(s2,fill_value=0)
   a    163.551964
   b     86.868903
   c     74.800287
   d     94.397815
   e     12.572728
   f     82.626782
   dtype: float64
   
       
   df1.add(df2)
   	A			B			C	   D
   a	108.377878	131.712144	 NaN	NaN
   b	NaN			NaN			NaN	   NaN
   c	NaN			NaN			NaN	   NaN
   d	101.297420	146.286951	 NaN	NaN
   f	NaN			NaN			NaN	   NaN
       
   df1.add(df2,fill_value=0)
   	A			B			C			D
   a	108.377878	131.712144	32.586599	94.539634
   b	46.996796	19.524614	74.472748	NaN
   c	94.605620	94.174812	29.406223	NaN
   d	101.297420	146.286951	21.006926	3.874301
   f	8.415423	52.471031	NaN			43.082653
   
   #使用fill_value指定填充值，未对齐的数据将和填充值进行运算
   #可以理解为不存在的索引，用指定的值（存在的索引的值）进行填充
   
   
   
   #在上表中,每个方法都有个以 r 开头的方法, r开头的方法参数是可以翻转的
   100 / df1 #100除以df1
   		A		B			C
   a	3.721746	1.416432	3.068746
   b	2.127805	5.121740	1.342773
   c	1.057020	1.061855	3.400641
   d	1.070560	1.782717	4.760335
   
   df1.rdiv(100) #同样也是100除以df1
   		A		B			C
   a	3.721746	1.416432	3.068746
   b	2.127805	5.121740	1.342773
   c	1.057020	1.061855	3.400641
   d	1.070560	1.782717	4.760335
   #这两种方法是等价的
   
   
   
   #对于我们的索引重建，如果某个索引值不存在会以NaN进行填充,我们也可以通过fill_value参数进行填充,填充的值由我们自己指定
   df1.reindex(columns=list('ABCE'),fill_value=0)
   	A			B			C		  E
   a	26.869112	70.599906	32.586599	0
   b	46.996796	19.524614	74.472748	0
   c	94.605620	94.174812	29.406223	0
   d	93.409041	56.094164	21.006926	0
   ```

3. DataFrame和Series混合运算

   ```python
   #DataFrame和Series的算术运算和我们的Numpy不同维度的运算操作类似
   #DataFrame与Series的数学操作会把Series的索引和DataFrame的列进行匹配，然后广播到行,大家可以参考我们Numpy的二维数组和一维数组的广播
   df1 #还是我们上面的df1
   	A			B			C
   a	26.869112	70.599906	32.586599
   b	46.996796	19.524614	74.472748
   c	94.605620	94.174812	29.406223
   d	93.409041	56.094164	21.006926
   
   s3 = df1.loc['a'] #获取df1的a行，是个series
   s4 = df1.A
   #dataframe 和series进行运算
   df1 + s3
   	A			B			C
   a	53.738224	141.199812	65.173199
   b	73.865908	90.124520	107.059347
   c	121.474731	164.774718	61.992822
   d	120.278153	126.694070	53.593525
   
   df1 + s4
   	A	B	C	a	b	c	d
   a	NaN	NaN	NaN	NaN	NaN	NaN	NaN
   b	NaN	NaN	NaN	NaN	NaN	NaN	NaN
   c	NaN	NaN	NaN	NaN	NaN	NaN	NaN
   d	NaN	NaN	NaN	NaN	NaN	NaN	NaN
   #可以明显看出Series的索引和DataFrame的列进行匹配,广播到各行
   
   
   #那么如果我们要在行上匹配，广播到行，
   # 1. 使用我们的算术方法,必须指定axis=0或axis='index'，传递的axis值是用于匹配轴的
   S4
   a    26.869112
   b    46.996796
   c    94.605620
   d    93.409041
   Name: A, dtype: float64
   
   df1.add(s4,axis='index')
   	A			B			C
   a	53.738224	97.469018	59.455711
   b	93.993592	66.521410	121.469543
   c	189.211239	188.780432	124.011843
   d	186.818082	149.503204	114.415967
   
   # 2. 我们可以将DataFrame进行转置,进行运算，然后在转置回到原来的数据结构
   df1.T
   	a			b			c			d
   A	26.869112	46.996796	94.605620	93.409041
   B	70.599906	19.524614	94.174812	56.094164
   C	32.586599	74.472748	29.406223	21.006926
   
   (df.T+s4).T
   	A			B			C
   a	53.738224	97.469018	59.455711
   b	93.993592	66.521410	121.469543
   c	189.211239	188.780432	124.011843
   d	186.818082	149.503204	114.415967
   #这两种方法都行，第二种转置的方法可能比较绕，推荐使用算术方法，指定轴进行匹配
   ```
