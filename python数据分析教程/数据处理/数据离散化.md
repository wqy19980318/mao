# 数据离散化

- **数据离散化**：*连续属性的离散化就是将连续属性值域划分为若干个离散的区间，最后用不同的符号或整数值代表落在每个子区间中的属性值。*

- **数据离散化的目的**：*决策树和朴素贝叶斯算法不能直接使用连续型变量，离散化可以有效克服数据中隐藏的缺陷，使模型结果更加稳定。*


##### cut*（x,bins,labels=None,right=True）*:

**x**:*类array对象，且必须为**一维**，待切割的原形式*
**bins**:*整数、序列尺度、或间隔索引。如果bins是一个整数，它定义了x宽度范围内的等宽面元数量。如果bin是序列，它定义了允许非均匀bin宽度的bin边缘。*
**right**:*布尔值。是否是左开右闭区间*
**labels**:*用作结果箱的标签。必须与结果箱相同长度。如果FALSE，只返回整数指标面元。*

```python
#一组年龄数据，进行区间划分
ages = [18,26,22,35,43,67,7,5,82]
bins = [0,18,30,50,90] #自定义分组区间
c1 = pd.cut(ages,bins) #返回一个特殊的Categorical对象,
c1
[(0, 18], (18, 30], (18, 30], (30, 50], (30, 50], (50, 90], (0, 18], (0, 18], (50, 90]]
Categories (4, interval[int64]): [(0, 18] < (18, 30] < (30, 50] < (50, 90]]
#Categorical对象有两个属性，
#Categories:包含了一个数组，指定了不同的类别名称  
c1.categories     
IntervalIndex([(0, 18], (18, 30], (30, 50], (50, 90]]
              closed='right',
              dtype='interval[int64]')

#codes:ages的数据标签，每个数据所在的区间标签
c1.codes                                   
array([0, 1, 1, 2, 2, 3, 0, 0, 3], dtype=int8)                                   
                                   
# 一般我们搭配value_counts()，进行计数
c1.value_counts()   #得到一个区间计数的Series
(0, 18]     3
(18, 30]    2
(30, 50]    2
(50, 90]    2
dtype: int64        
 
 
 #若bins为整数,pandas会根据最小值和最大值来计算等长的区间
 c2 = pd.cut(ages,4)
 c2
 [(4.923, 24.25], (24.25, 43.5], (4.923, 24.25], (24.25, 43.5], (24.25, 43.5], (62.75, 82.0], (4.923, 24.25], (4.923, 24.25], (62.75, 82.0]]
Categories (4, interval[float64]): [(4.923, 24.25] < (24.25, 43.5] < (43.5, 62.75] < (62.75, 82.0]]
 #划分4个等长的区间,                                                                                     
```



##### qcut*（x,bins,labels=None,right=True）*:基于样本分位数进行划分区间,取决于数据的分布

**分位数**：就是连续分布函数中的一个点，这个点对应概率p。

**x**:*类array对象，且必须为**一维**，待切割的原形式*
**bins**:*整数、或分位数组成的数组。*
**labels**:*用作结果箱的标签。必须与结果箱相同长度。如果FALSE，只返回整数指标面元。*

```python
ages = [18,26,22,35,43,67,7,5,82]
c1 = pd.qcut(ages,4)
c1
[(4.999, 18.0], (18.0, 26.0], (18.0, 26.0], (26.0, 43.0], (26.0, 43.0], (43.0, 82.0], (4.999, 18.0], (4.999, 18.0], (43.0, 82.0]]
Categories (4, interval[float64]): [(4.999, 18.0] < (18.0, 26.0] < (26.0, 43.0] < (43.0, 82.0]]

c1.value_counts() #可以看出，qcut尽可能满足每个区间的值的个数相等
(4.999, 18.0]    3
(18.0, 26.0]     2
(26.0, 43.0]     2
(43.0, 82.0]     2
dtype: int64                                                                            
 #自定义分位数
pd.qcut(ages,[0,0.1,0.5,0.7,1]).value_counts()
(4.999, 6.6]    1
(6.6, 26.0]     4
(26.0, 39.8]    1
(39.8, 82.0]    3
dtype: int64
```

